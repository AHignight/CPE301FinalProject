// Name: Andrew Hignight, Mathew Rios, Ean McNeil, Michael Wang
// Date: 12/1/2022

/*
PORT ASSIGNMENTS:

 DHT:
  >PB6 = DHT pin

 RCT:
  >PD1 = SDA
  >PD0 = SCL
  
 State LED indicators:
  >PK0 = Red ERROR LED
  >PK1 = Yellow DISABLED LED
  >PK2 = Green IDLE LED
  >PK3 = BLue RUNNING IDLE

 Stepper Motor:
  >PE4 = 1N4
  >PE5 = 1N2
  >PG5 = 1N3
  >PE3 = 1N1
  >PL0 = button 1
  >PL1 = button 2

 Disabled Button:
  >PA1 = disable

 LCD Display:
  >PH3 = D7
  >PH4 = D6
  >PH5 = D5
  >PH6 = D4
  >PB4 = E
  >PB5 = RS

 DC Fan Motor:
  >PL6 = Fan motor enable   
 
*/

// Libraries
#include <dht_nonblocking.h>
#include <Adafruit_Sensor.h>
#include <DHT.h>
#include <DHT_U.h>
#include <LiquidCrystal.h>
#include <Wire.h>
#include <RTClib.h>
#include <Stepper.h>

// DHT
#define DHTPIN 12
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// RTC module
RTC_DS1307 rtc;
// RTC days of the week array
char daysOfTheWeek[7][12] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

// LCD declarations
LiquidCrystal lcd(11,10,9,8,7,6); //sets lcd pin locations at from pins 6-11 (PH3-PH6,PB4,PB5)
#define DHT_SENSOR_TYPE DHT_TYPE_11
int DHT_SENSOR_PIN = 12; //sets pin to 12 (PB6)
DHT_nonblocking dht_sensor(DHT_SENSOR_PIN,DHT_SENSOR_TYPE);

// Stepper Motor
const int stepsPerRev = 256;
Stepper myStepper(stepsPerRev, 2, 3, 4, 5); //initializes stepper motor on pins 8-11

// Global Variables
char error_flag = 0;
char disable_flag = 0;
unsigned char WATER_LEVEL_PORT = 0; // WATER LEVEL ANALOG PORT A0
int current_temp = 0; // Water Sensor
int count = 0;

// Declaring Functions
void setup_timer_registers();
void error_state();
void idle_state();
void running_state();
void disabled_state();

// Define data registers and ports
#define SET_OUTPUT(ddr, pin) *ddr |= (0x01 << pin);
#define SET_INPUT(ddr, pin) *ddr &= ~(0x01 << pin);
#define SET_HIGH(port, pin) *port |= (0x01 << pin);
#define SET_LOW(port, pin) *port &= ~(0x01 << pin);

// Register F
volatile unsigned char* port_F = (unsigned char) 0x31;
volatile unsigned char* ddr_F = (unsigned char) 0x30;
volatile unsigned char* pin_F = (unsigned char) 0x2F;

// Port A Register 
volatile unsigned char* port_a = (unsigned char*) 0x22;
volatile unsigned char* ddr_a = (unsigned char*) 0x21;
volatile unsigned char* pin_a = (unsigned char*) 0x20;

// Port B Register 
volatile unsigned char* port_b = (unsigned char*) 0x25;
volatile unsigned char* ddr_b = (unsigned char*) 0x24;
volatile unsigned char* pin_b = (unsigned char*) 0x23;

// Define Port F Register 
volatile unsigned char* port_f = (unsigned char*) 0x31; 
volatile unsigned char* ddr_f  = (unsigned char*) 0x30; 
volatile unsigned char* pin_f  = (unsigned char*) 0x2F; 

// Port L Registers 
volatile unsigned char* port_l = (unsigned char*) 0x10B;
volatile unsigned char* ddr_l = (unsigned char*) 0x10A;
volatile unsigned char* pin_l = (unsigned char*) 0x109;

// Port D Registers 
volatile unsigned char* port_d = (unsigned char*) 0x0B;
volatile unsigned char* ddr_d = (unsigned char*) 0x0A;
volatile unsigned char* pin_d = (unsigned char*) 0x09;

// Port K Registers
volatile unsigned char* port_k = (unsigned char*) 0x108; 
volatile unsigned char* ddr_k = (unsigned char*) 0x107;
volatile unsigned char* pin_k = (unsigned char*) 0x106;

// External ISR Registers Control and Mask
volatile unsigned char* my_ECIRA = (unsigned char*) 0x69;
volatile unsigned char* my_EIMSK = (unsigned char*) 0x3D;

// ADC Register
volatile unsigned char* my_ADMUX = (unsigned char) 0x7C;
volatile unsigned char* my_ADCSRB = (unsigned char) 0x7B;
volatile unsigned char* my_ADCSRA = (unsigned char) 0x7A;
volatile unsigned int* my_ADC_DATA = (unsigned char) 0x78;

// THRESHOLDS
#define TEMPERATURE_THRESHOLD_F 70.0000
#define TEMPERATURE_THRESHOLD_C 21.1111
#define WATER_LEVEL_THRESHOLD 100

// Flags depicting what state we are in.
enum state {
   off = 0,
   idle = 1,
   temp = 2,
   water = 3
};
// Begin in off state.
enum state stat = off;

// ISR
ISR(TIMER0_vect) //ISR for Timer0
{
  if(disable_flag == 1){
    disabled_state();
  } else {
    int water_level = adc_read(WATER_LEVEL_PORT);
    
    if(water_level < WATER_LEVEL_THRESHOLD) {
      // The water level is too low
      error_state();
    } else {
      // Check if temperature is above the threshold
      if(current_temp < TEMPERATURE_THRESHOLD_C) {
        // Temperature is low; stop the fan
	idle_state();
      } else {
      // Temperature is high; start the fan
      running_state();
      }
    }
  }
}

void setup() {
 while (!Serial); 
 Serial.begin(9600);
 // ADC setup
   adc_init();
  // set PF2 as input with pullup resistor;
  *ddr_F &= 0x00;
  *port_F |= 0xFF;
  *ddr_a |= 0x02;
  // RTC setup
 if (! rtc.begin()) {
   Serial.println("Couldn't find RTC");
   while (1);
 }
 if (! rtc.isrunning()) {
   Serial.println("RTC is NOT running!");
   // following line sets the RTC to the date & time this sketch was compiled
   rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
   // This line sets the RTC with an explicit date & time, for example to set
   // January 21, 2014 at 3am you would call:
   // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
 }
  
  // Stepper Motor
  myStepper.setSpeed(32); //sets stepper motor speed to 60 rpm
  SET_INPUT((unsigned char*) 0x10A, 0); //PL0 set as input
  SET_INPUT((unsigned char*) 0x10A, 1); //PL1 sets as input
  
  //Setting up lcd for temp/humd
  lcd.begin(16, 2);  	 //enables 16x2 lcd screen spaces
  // pinMode (inputW, INPUT);
  // pinMode (outputW, OUTPUT);
  dht.begin();
}

void loop() {
if (*pin_a & 0b00000010){
  disable_flag = 1;
  for(volatile unsigned int i=0; i < 1000; i++);
  lcd.clear();
  lcd.noDisplay();
  while(*pin_a & 0b00000010);
  disable_flag = 0;
  lcd.display ();
} else {
// Reads temperature and humidity
int t = dht.readTemperature();
int h = dht.readHumidity();
current_temp = t;
}
unsigned int w = adc_read(WATER_LEVEL_PORT);
float f = temperatureRead(true);
float h = humidity();

// RTC loop for time and date
 DateTime now = rtc.now();
 Serial.print("Time: ");
 Serial.print(now.hour(), DEC);
 Serial.print(':');
 Serial.print(now.minute(), DEC);
 Serial.print(':');
 Serial.print(now.second(), DEC);
 Serial.print(" Date: ");
 Serial.print(now.month(), DEC);
 Serial.print('/');
 Serial.print(now.day(), DEC);
 Serial.print('/');
 Serial.print(now.year(), DEC);
 Serial.print(" (");
 Serial.print(daysOfTheWeek[now.dayOfTheWeek()]);
 Serial.print(") ");
 Serial.println();
 delay(5000);
 
 // get the reading from the ADC
unsigned int adc_reading = adc_read(0); // number used is Analog pin Number
// print it to the serial port
Serial.println(adc_reading);
 
// Stepper Motor 
  if (*pin_l & 0x01){
    Serial.print("rotate ");
    // 2048 / 8 = 256
    // This is how many steps per revolution to create a 45 degree angle per button press
    Serial.print(stepsPerRev / 5.68889 ); 
    Serial.println("° clockwise");
    myStepper.step(-stepsPerRev); //negative value sends stepPerRev in reverse direvtion
    
    //Displays the time and angle the vent was changed on the lcd monitor
    Serial.print("Vent Open ");
    Serial.print(stepsPerRev / 5.68889);
    Serial.print(" degrees on: ");
    Serial.print(daysOfTheWeek[now.dayOfTheWeek()]);
    Serial.print(" ");
    Serial.print(now.month(), DEC);
    Serial.print('/');
    Serial.print(now.day());
    Serial.print('/');
    Serial.println(now.year(), DEC);
    Serial.print(" at ");
    Serial.print(now.hour(), DEC);
    Serial.print(':');
    Serial.print(now.minute(), DEC);
    Serial.print(':');
    Serial.println(now.second(), DEC);
    delay(100);
  }

else if (*pin_l & 0x02){
    Serial.print("rotate ");
    Serial.print(stepsPerRev / 5.68889 );
    Serial.println("° counter-clockwise");
    myStepper.step(stepsPerRev);
    
    //Displays the time and angle the vent was changed on the lcd monitor
    Serial.print("Vent closed ");
    Serial.print(stepsPerRev / 5.68889);
    Serial.print(" degrees on: ");
    Serial.print(daysOfTheWeek[now.dayOfTheWeek()]);
    Serial.print(" ");
    Serial.print(now.month(), DEC);
    Serial.print('/');
    Serial.print(now.day());
    Serial.print('/');
    Serial.println(now.year(), DEC);
    Serial.print(" at ");
    Serial.print(now.hour(), DEC);
    Serial.print(':');
    Serial.print(now.minute(), DEC);
    Serial.print(':');
    Serial.println(now.second(), DEC);
    delay(100);
  }
  // Choose State Space
  switch(stat) {
    case off:
      Serial.println("Disabled State");
      disabled_state();
      break;
    case idle:
      Serial.println("Idle State");
      idle_state();
      break;
    case water:
      Serial.println("Error State");
      error_state();
      break;
    case temp:
      Serial.println("Running State");
      running_state();
      break;
    default:
      break;
  }
}

// GET WATER LEVEL FROM ANALOG PORT 0
unsigned int water_level() {
  return adc_read(WATER_LEVEL_PORT);
}

// GET TEMPERATURE FROM DHT11
float temperatureRead(bool F) {
  float t;
  if (F) t = dht.readTemperature(true); // Fahrenheit
  else t = dht.readTemperature();       // Celsius
  if (isnan(t)) Serial.println(F("Failed to read temperature from DHT sensor!"));
  current_temp = t;
  return t;
}

// GET HUMIDITY FROM DHT11
float humidity() {
  float h = dht.readHumidity();
  if (isnan(h)) Serial.println(F("Failed to read humidity from DHT sensor!"));
  return h;
}

// OUTPUT TEMPERATURE AND HUMIDITY TO LCD
void lcd_th(float t, float h) {
  lcd.setCursor(0, 0);
  lcd.print("Temp:  Humidity:");
  lcd.setCursor(0, 1);
  lcd.print(t);
  lcd.setCursor(7, 1);
  lcd.print(h);
}

// ADC setup
void adc_init()
{
  // set up the A register
  *my_ADCSRA |= 0x80; // set bit   7 to 1 to enable the ADC
  *my_ADCSRA &= 0xDF; // clear bit 5 to 0 to disable the ADC trigger mode
  *my_ADCSRA &= 0xF7; // clear bit 3 to 0 to disable the ADC interrupt
  *my_ADCSRA &= 0xF8; // clear bit 2-0 to 0 to set prescaler selection to slow reading
  // set up the B register
  *my_ADCSRB &= 0xF7; // clear bit 3 to 0 to reset the channel and gain bits
  *my_ADCSRB &= 0xF8; // clear bit 2-0 to 0 to set free running mode
  // set up the MUX Register
  *my_ADMUX  &= 0x7F; // clear bit 7 to 0 for AVCC analog reference
  *my_ADMUX  |= 0x40; // set bit   6 to 1 for AVCC analog reference
  *my_ADMUX  &= 0xDF; // clear bit 5 to 0 for right adjust result
  *my_ADMUX  &= 0xE0; // clear bit 4-0 to 0 to reset the channel and gain bits
}

unsigned int adc_read(unsigned char adc_channel_num)
{
  // reset the channel and gain bits
  *my_ADMUX  &= 0xE0;
  // clear the channel selection bits
  *my_ADCSRB &= 0xF7;
  // set the channel number
  if(adc_channel_num > 7)
  {
    // set the channel selection bits, but remove the most significant bit (bit 3)
    adc_channel_num -= 8;
    // set MUX bit 
    *my_ADCSRB |= 0x08;
  }
  // set the channel selection bits
  *my_ADMUX  += adc_channel_num;
  // set bit 6 of ADCSRA to 1 to start a conversion
  *my_ADCSRA |= 0x40;
  // wait for the conversion to complete
  while((*my_ADCSRA & 0x40)==1);
  // return the result in the ADC data register
  return *my_ADC_DATA;
}

// Enables the timer and interrupts
void setup_timer_registers() {
// Setup the timer control registers.
  OCR0A = 100;
  TCCR0A |= 0b00000010;   // CTC mode, internal clk, no prescaler
  TCCR0B |= 0b00000001;   // Start the timer, no prescaler                    
  TIMSK0 |= 0b00000010;   // Enable Timer0 Compare Match A Interrupt
  sei();		  // Enable interrupts
}

// When water level is too low
void error_state() {

//sets pin to PK0
  *port_k |= 0b00000001;    // Turn on the red LED
  *port_k &= 0b00000001;    // Turn off the rest
  *port_k &= 0b11110111;    // Turn off the motor
  
  lcd.clear();
  lcd.print("Water Level Low");
  unsigned int w = water_level();

  //measures water level until okay
  while(w < WATER_LEVEL_THRESHOLD){
    delay(1000);
    w = water_level();
    lcd.setCursor(0,1);
    lcd.print("Level: ");
    lcd.setCursor(7,1);
    lcd.print(w);
  }

  stat = idle;
  lcd.clear();
  error_flag = 1;
}

// When monitoring and fan are disabled using an on/off button
void disabled_state() {

//sets pin to PK1
  *port_k |= 0b00000010;    // Turn on the yellow LED
  *port_k &= 0b00000010;    // Turn off the rest
  *port_k &= 0b11110111;    // Turn off the motor
  
  stat = idle; //press start button and initiate idle state
  lcd.display();
  error_flag = 0;
}

// When water level is and temperature is low
void idle_state() {
//sets pin to PK2
  *port_k |= 0b00000100;    // Turn on the green LED
  *port_k &= 0b00000100;    // Turn off the rest
  *port_k &= 0b11110111;    // Turn off the motor
  
  //gets measurements
  unsigned int w = water_level();
  float t = temperatureRead(true);
  float h = humidity();

  //Displays current readings
  lcd_th(t,h);

  //Water level check
  if(w < WATER_LEVEL_THRESHOLD){
    stat = water;
  }
  //Temp check
  else if (t > TEMPERATURE_THRESHOLD_F){
    stat = temp;
  }
  error_flag = 0;
}

// When water level is good but temperature is too high
void running_state() {
//sets pin to PK3
  *port_k |= 0b00001000;    // Turn on the blue LED
  *port_k &= 0b00001000;    // Turn off the rest
  *port_k |= 0b00001000;    // Turn on the motor
  
  float f = temperatureRead(true);
  float h = humidity();

  //Water and Temp check
  if(water_level() < WATER_LEVEL_THRESHOLD){
    stat = water;
  }else if(f > TEMPERATURE_THRESHOLD_F){
    delay(1000);
    Serial.print("Temperature: ");
    Serial.print(f);
    Serial.print('\n');
    lcd_th(f,h);
    return running_state();
  }else{
    lcd.clear();
    stat = idle;
  }
  error_flag = 0; 
}
