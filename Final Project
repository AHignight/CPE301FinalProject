// Name: Andrew Hignight, Mathew Rios, Ean McNeil, Michael Wang
// Date: 12/1/2022

// Libraries
#include <dht_nonblocking.h>
#include <Adafruit_Sensor.h>
#include <DHT.h>
#include <DHT_U.h>
#include <LiquidCrystal.h>
#include <Wire.h>
#include <RTClib.h>
#include <Stepper.h>

// DHT
#define DHTPIN 2
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// ADC Register
volatile unsigned char* my_ADMUX = (unsigned char) 0x7C;
volatile unsigned char* my_ADCSRB = (unsigned char) 0x7B;
volatile unsigned char* my_ADCSRA = (unsigned char) 0x7A;
volatile unsigned int* my_ADC_DATA = (unsigned char) 0x78;

volatile unsigned char* port_F = (unsigned char) 0x31;
volatile unsigned char* ddr_F = (unsigned char) 0x30;
volatile unsigned char* pin_F = (unsigned char) 0x2F;

// RTC days of the week array
RTC_DS1307 rtc;
char daysOfTheWeek[7][12] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

// LCD declarations
LiquidCrystal lcd(11,10,9,8,7,6); 
#define DHT_SENSOR_TYPE DHT_TYPE_11
int DHT_SENSOR_PIN = 12;
DHT_nonblocking dht_sensor(DHT_SENSOR_PIN,DHT_SENSOR_TYPE);

// Stepper Motor
const int stepsPerRev = 256;
Stepper myStepper(stepsPerRev, 2, 3, 4, 5); //initializes stepper motor on pins 8-11

// Define data registers and ports
#define SET_OUTPUT(ddr, pin) *ddr |= (0x01 << pin);
#define SET_INPUT(ddr, pin) *ddr &= ~(0x01 << pin);
#define SET_HIGH(port, pin) *port |= (0x01 << pin);
#define SET_LOW(port, pin) *port &= ~(0x01 << pin);

// Port A Register Pointers
volatile unsigned char* port_A = (unsigned char*) 0x22;
volatile unsigned char* ddr_A = (unsigned char*) 0x21;
volatile unsigned char* pin_A = (unsigned char*) 0x20;

// Port B Register Pointers
volatile unsigned char* port_b = (unsigned char*) 0x25;
volatile unsigned char* ddr_b = (unsigned char*) 0x24;
volatile unsigned char* pin_b = (unsigned char*) 0x23;

// Define Port F Register Pointers
volatile unsigned char* port_f = (unsigned char*) 0x11; 
volatile unsigned char* ddr_f  = (unsigned char*) 0x10; 
volatile unsigned char* pin_f  = (unsigned char*) 0x0F; 

// Port L Registers Pointers
volatile unsigned char* port_l = (unsigned char*) 0x10B;
volatile unsigned char* ddr_l = (unsigned char*) 0x10A;
volatile unsigned char* pin_l = (unsigned char*) 0x109;

// Port D Registers Pointers
volatile unsigned char* port_d = (unsigned char*) 0x0B;
volatile unsigned char* ddr_d = (unsigned char*) 0x0A;
volatile unsigned char* pin_d = (unsigned char*) 0x09;

// External ISR Registers Control and Mask
volatile unsigned char* my_ECIRA = (unsigned char*) 0x69;
volatile unsigned char* my_EIMSK = (unsigned char*) 0x3D;
int count = 0;

/*
// ISR
ISR(INT2_vect){
count ++;
state_change = 1;
// **
if(count%2 == 1) {
	disabled_state = false;
	running_state = false;
	error_state = false;
	idle_state = true;
}
// **
else {
	idle_state = false;
	running_state = false;
	error_state = false;
	disabled_state = true;
}
} 
*/

// WATER LEVEL ANALOG PORT A0
unsigned char WATER_LEVEL_PORT = 0;

// THRESHOLDS
#define TEMPERATURE_THRESHOLD_F 80.0000
#define TEMPERATURE_THRESHOLD_C 26.6667
#define WATER_LEVEL_THRESHOLD 100

// Flags depicting what state we are in.
enum state {
   off = 0,
   idle = 1,
   temp = 2,
   water = 3
};

// Begin in off state.
enum state stat = off;

void setup() {
 while (!Serial); 
 Serial.begin(9600);
 // ADC setup
   adc_init();
  // set PF2 as input with pullup resistor;
  *ddr_F &= 0x00;
  *port_F |= 0xFF;
  // RTC setup
 if (! rtc.begin()) {
   Serial.println("Couldn't find RTC");
   while (1);
 }
 if (! rtc.isrunning()) {
   Serial.println("RTC is NOT running!");
   // following line sets the RTC to the date & time this sketch was compiled
   rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
   // This line sets the RTC with an explicit date & time, for example to set
   // January 21, 2014 at 3am you would call:
   // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
 }
 
  // Stepper Motor
  myStepper.setSpeed(32); //sets stepper motor speed to 60 rpm
  SET_INPUT((unsigned char*) 0x10A, 0); //PL0 set as input
  SET_INPUT((unsigned char*) 0x10A, 1); //PL1 sets as input
  
  //Setting up lcd for temp/humd
  lcd.begin(16, 2);  	 //enables 16x2 lcd screen spaces
  // pinMode (inputW, INPUT);
  // pinMode (outputW, OUTPUT);
}

void loop() {
// RTC loop for time and date
 DateTime now = rtc.now();
 Serial.print("Time: ");
 Serial.print(now.hour(), DEC);
 Serial.print(':');
 Serial.print(now.minute(), DEC);
 Serial.print(':');
 Serial.print(now.second(), DEC);
 Serial.print(" Date: ");
 Serial.print(now.month(), DEC);
 Serial.print('/');
 Serial.print(now.day(), DEC);
 Serial.print('/');
 Serial.print(now.year(), DEC);
 Serial.print(" (");
 Serial.print(daysOfTheWeek[now.dayOfTheWeek()]);
 Serial.print(") ");
 Serial.println();
 delay(5000);
 
 // get the reading from the ADC
unsigned int adc_reading = adc_read(0); // number used is Analog pin Number
// print it to the serial port
Serial.println(adc_reading);
 
// Stepper Motor 
  if (*pin_l & 0x01){
    Serial.print("rotate ");
    // 2048 / 8 = 256
    // This is how many steps per revolution to create a 45 degree angle per button press
    Serial.print(stepsPerRev / 5.68889 ); 
    Serial.println("° clockwise");
    myStepper.step(-stepsPerRev); //negative value sends stepPerRev in reverse direvtion
    
    //Displays the time and angle the vent was changed on the lcd monitor
    lcd.print("Vent closed ");
    lcd.print(stepsPerRev / 5.68889);
    lcd.print(" degrees on: ");
    lcd.print(daysOfTheWeek[now.dayOfTheWeek()]);
    lcd.print(" ");
    lcd.print(now.month(), DEC);
    lcd.print('/');
    lcd.print(now.day());
    lcd.print('/');
    lcd.println(now.year(), DEC);
    lcd.print(" at ");
    lcd.print(now.hour(), DEC);
    lcd.print(':');
    lcd.print(now.minute(), DEC);
    lcd.print(':');
    lcd.print(now.second(), DEC);
    
    delay(15000);
  }

else if (*pin_l & 0x02){
    Serial.print("rotate ");
    Serial.print(stepsPerRev / 5.68889 );
    Serial.println("° counter-clockwise");
    myStepper.step(stepsPerRev);
    
    //Displays the time and angle the vent was changed on the lcd monitor
    lcd.print("Vent closed ");
    lcd.print(stepsPerRev / 5.68889);
    lcd.print(" degrees on: ");
    lcd.print(daysOfTheWeek[now.dayOfTheWeek()]);
    lcd.print(" ");
    lcd.print(now.month(), DEC);
    lcd.print('/');
    lcd.print(now.day());
    lcd.print('/');
    lcd.println(now.year(), DEC);
    lcd.print(" at ");
    lcd.print(now.hour(), DEC);
    lcd.print(':');
    lcd.print(now.minute(), DEC);
    lcd.print(':');
    lcd.print(now.second(), DEC);
    
    delay(15000);
  }
  // Choose State Space
  switch(stat) {
    case off:
      Serial.println("Disabled State");
      disabled_state();
      break;
    case idle:
      Serial.println("Idle State");
      idle_state();
      break;
    case water:
      Serial.println("Error State");
      error_state();
      break;
    case temp:
      Serial.println("Running State");
      running_state();
      break;
    default:
      break;
  }
}

/*///////////////////
  MACHINE STATES
///////////////////*/
void disabled_state() { // Or off state
  lcd.clear();
  lcd.noDisplay();

  *port_b &= 0b10000001; // Turn off all LEDs
  *port_b |= 0b00001000; // Turn on Yellow LED
  
  // Listen to PB7 and await low signal
  while ( (*pin_b & (1 << 7)) == 0) { }

  // Start button pressed and initialize idle state.
  stat = idle;
  lcd.display();
}

void idle_state() {
  *port_b |= 0b01000000; // Turn on green LED
  *port_b &= 0b01000000; // Turn off other LEDs & fan
  
  // Get water level, temperature, and humidity
  unsigned int w = water_level();
  float t = temperatureRead(true);
  float h = humidity();

  // Display temperature and humidity to screen
  lcd_th(t, h);

  // Check water level.
  if (w < WATER_LEVEL_THRESHOLD) stat = water;
  
  // Check temperature.
  else if (t > TEMPERATURE_THRESHOLD_F) stat = temp;
}

void error_state() {
  *port_b |= 0b00100000; // Turn on red LED
  *port_b &= 0b00100000; // Turn off other LEDs
  
  lcd.clear();
  lcd.print("Low Water");

  unsigned int w = water_level();

  // Wait for water level to increase
  while (w < WATER_LEVEL_THRESHOLD) {
    delay(1000);
    w = water_level();
    lcd.setCursor(0, 1);
    lcd.print("Level:");
    lcd.setCursor(7, 1);
    lcd.print(w);
}
  
  // Water level is now okay
  stat = idle;
  lcd.clear();
}

void running_state()
{
  *port_b |= 0b00010000; // Enable fan and running LED
  *port_b &= 0b00010000; // Disable other LEDs
  float f = temperatureRead(true);
  float h = humidity();

  // Check water level and temperature
  if (water_level() < WATER_LEVEL_THRESHOLD) stat = water;
  else if ( f > TEMPERATURE_THRESHOLD_F ) {
    delay(1000);
    Serial.print("Temp: ");
    Serial.print(f);
    Serial.print('\n');
    lcd_th(f, h);
    return running_state();
  }
  else {
    lcd.clear();
    stat = idle;
  }
}

/*///////////////////
 UTILITY FUNCTIONS
///////////////////*/

// GET WATER LEVEL FROM ANALOG PORT 0
unsigned int water_level() {
  return adc_read(WATER_LEVEL_PORT);
}

// GET TEMPERATURE FROM DHT11
float temperatureRead(bool F) {
  float t;
  if (F) t = dht.readTemperature(true); // Fahrenheit
  else t = dht.readTemperature();       // Celsius
  if (isnan(t)) Serial.println(F("Failed to read temperature from DHT sensor!"));
  return t;
}

// GET HUMIDITY FROM DHT11
float humidity() {
  float h = dht.readHumidity();
  if (isnan(h)) Serial.println(F("Failed to read humidity from DHT sensor!"));
  return h;
}

// OUTPUT TEMPERATURE AND HUMIDITY TO LCD
void lcd_th(float t, float h) {
  lcd.setCursor(0, 0);
  lcd.print("Temp:  Humidity:");
  lcd.setCursor(0, 1);
  lcd.print(t);
  lcd.setCursor(7, 1);
  lcd.print(h);
}

// ADC setup
void adc_init()
{
  // set up the A register
  *my_ADCSRA |= 0x80; // set bit   7 to 1 to enable the ADC
  *my_ADCSRA &= 0xDF; // clear bit 5 to 0 to disable the ADC trigger mode
  *my_ADCSRA &= 0xF7; // clear bit 3 to 0 to disable the ADC interrupt
  *my_ADCSRA &= 0xF8; // clear bit 2-0 to 0 to set prescaler selection to slow reading
  
  // set up the B register
  *my_ADCSRB &= 0xF7; // clear bit 3 to 0 to reset the channel and gain bits
  *my_ADCSRB &= 0xF8; // clear bit 2-0 to 0 to set free running mode
  
  // set up the MUX Register
  *my_ADMUX  &= 0x7F; // clear bit 7 to 0 for AVCC analog reference
  *my_ADMUX  |= 0x40; // set bit   6 to 1 for AVCC analog reference
  *my_ADMUX  &= 0xDF; // clear bit 5 to 0 for right adjust result
  *my_ADMUX  &= 0xE0; // clear bit 4-0 to 0 to reset the channel and gain bits
}

unsigned int adc_read(unsigned char adc_channel_num)
{
  // reset the channel and gain bits
  *my_ADMUX  &= 0xE0;
  
  // clear the channel selection bits
  *my_ADCSRB &= 0xF7;
  
  // set the channel number
  if(adc_channel_num > 7)
  {
    // set the channel selection bits, but remove the most significant bit (bit 3)
    adc_channel_num -= 8;
    
    // set MUX bit 
    *my_ADCSRB |= 0x08;
  }
  
  // set the channel selection bits
  *my_ADMUX  += adc_channel_num;
  
  // set bit 6 of ADCSRA to 1 to start a conversion
  *my_ADCSRA |= 0x40;
  
  // wait for the conversion to complete
  while((*my_ADCSRA & 0x40)==1);
  
  // return the result in the ADC data register
  return *my_ADC_DATA;
}

//comment out
/*
// Enables the timer and interrupts
void setup_timer_registers() {
// Setup the timer control registers.
  OCR0A = 100;
  TCCR0A |= 0b00000010;   // CTC mode, internal clk, no prescaler
  TCCR0B |= 0b00000001;   // Start the timer, no prescaler                    
  TIMSK0 |= 0b00000010;   // Enable Timer0 Compare Match A Interrupt
}

// When water level is too low
void error_state() {
  *port_b |= 0b00010000;    // Turn on the red LED
  *port_b &= 0b00011111;    // Turn off the rest
  *port_f &= 0b11110111;    // Turn off the motor
  error_flag = 1;
}

// When monitoring and fan are disabled using an on/off button
void disabled_state() {
  *port_b |= 0b00100000;    // Turn on the yellow LED
  *port_b &= 0b00101111;    // Turn off the rest
  *port_f &= 0b11110111;    // Turn off the motor
  error_flag = 0;
}

// When water level is and temperature is low
void idle_state() {
  *port_b |= 0b01000000;    // Turn on the green LED
  *port_b &= 0b01001111;    // Turn off the rest
  *port_f &= 0b11110111;    // Turn off the motor
  error_flag = 0;
}

//Separate calculation	
static bool measure_environment(float *temp, float *humd)
{
	//calculating timestamp per milliseconds
  static unsigned long measurement_timestamp=millis();
  if(millis()-measurement_timestamp>3000ul)
  {
    if(dht_sensor.measure(temp,humd) == true)
    {
      measurement_timestamp = millis();
      return(true);
    }
  }
  return(false);
}
*/
