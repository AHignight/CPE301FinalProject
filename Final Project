// Name: Andrew Hignight, Mathew Rios, Ean McNeil, Michael Wang
// Date: 12/1/2022

// Libraries
#include <dht_nonblocking.h>
#include <Adafruit_Sensor.h>
#include <DHT.h>
#include <DHT_U.h>
#include <LiquidCrystal.h>
#include <Wire.h>
#include <RTClib.h>

// RTC days of the week array
RTC_DS1307 rtc;
char daysOfTheWeek[7][12] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

// LCD declarations
LiquidCrystal lcd(12,11,5,4,3,2); 
#define DHT_SENSOR_TYPE DHT_TYPE_11
int DHT_SENSOR_PIN = 9;
DHT_nonblocking dht_sensor(DHT_SENSOR_PIN,DHT_SENSOR_TYPE);

// Bool Functions declarations
bool disabled_state, idle_state, running_state, error_state;

// Stepper Motor
const int stepsPerRev = 256;
Stepper myStepper(stepsPerRev, 8, 9, 10, 11); //initializes stepper motor on pins 8-11

// Definitions libraries, global definitions and declarations, etc
int current_state;
int state_change = 0;
float Threshold_Temperature = 20;

// Declaring variable for temp and humd which are decimal values
float temp;
float humd;
int Waterval = 0;  // holds the value
int inputW = 7; // sensor pin used
int outputW = 11; //output to the lcd

// Define data registers and ports
#define SET_OUTPUT(ddr, pin) *ddr |= (0x01 << pin);
#define SET_INPUT(ddr, pin) *ddr &= ~(0x01 << pin);
#define SET_HIGH(port, pin) *port |= (0x01 << pin);
#define SET_LOW(port, pin) *port &= ~(0x01 << pin);

// Port A Register Pointers
volatile unsigned char* port_A = (unsigned char*) 0x22;
volatile unsigned char* ddr_A = (unsigned char*) 0x21;
volatile unsigned char* pin_A = (unsigned char*) 0x20;

// Port B Register Pointers
volatile unsigned char* port_b = (unsigned char*) 0x25;
volatile unsigned char* ddr_b = (unsigned char*) 0x24;
volatile unsigned char* pin_b = (unsigned char*) 0x23;

// Define Port F Register Pointers
volatile unsigned char* port_f = (unsigned char*) 0x11; 
volatile unsigned char* ddr_f  = (unsigned char*) 0x10; 
volatile unsigned char* pin_f  = (unsigned char*) 0x0F; 

// Port L Registers Pointers
volatile unsigned char* port_l = (unsigned char*) 0x10B;
volatile unsigned char* ddr_l = (unsigned char*) 0x10A;
volatile unsigned char* pin_l = (unsigned char*) 0x109;

// Port D Registers Pointers
volatile usigned char* port_d = (usigned char*) 0x0B;
volatile usigned char* ddr_d = (usigned char*) 0x0A;
volatile usigned char* pin_d = (usigned char*) 0x09;

// ADC Register 
volatile unsigned char* my_ADMUX = (unsigned char*) 0x7C;
volatile unsigned char* my_ADCSRB = (unsigned char*) 0x7B;
volatile unsigned char* my_ADCSRA = (unsigned char*) 0x7A;
volatile unsigned char* my_ADC_Data = (unsigned char*) 0x78;

// External ISR Registers Control and Mask
volatile unsigned char* my_ECIRA = (unsigned char*) 0x69;
volatile unsigned char* my_EIMSK = (unsigned char*) 0x3D;
int count = 0;

// Initialize ADC
void adc_init()
{
  // setup the ADC A register
  *my_ADCSRA |= 0b10000000; // set bit   7 to 1 to enable the ADC
  *my_ADCSRA &= 0b11011111; // clear bit 5 to 0 to disable the ADC trigger mode
  *my_ADCSRA &= 0b11011111; // clear bit 5 to 0 to disable the ADC interrupt
  *my_ADCSRA &= 0b11011111; // clear bit 5 to 0 to set prescaler selection to slow reading
  // setup the ADC B register
  *my_ADCSRB &= 0b11110111; // clear bit 3 to 0 to reset the channel and gain bits
  *my_ADCSRB &= 0b11111000; // clear bit 2-0 to 0 to set free running mode
  // setup the MUX Register
  *my_ADMUX  &= 0b01111111; // clear bit 7 to 0 for AVCC analog reference
  *my_ADMUX  |= 0b01000000; // set bit   6 to 1 for AVCC analog reference
  *my_ADMUX  &= 0b11011111; // clear bit 5 to 0 for right adjust result
  *my_ADMUX  &= 0b11011111; // clear bit 5 to 0 for right adjust result
  *my_ADMUX  &= 0b11100000; // clear bit 4-0 to 0 to reset the channel and gain bits
}

// ISR
ISR(INT2_vect){
count ++;
state_change = 1;
// **
if(count%2 == 1) {
	disabled_state = false;
	running_state = false;
	error_state = false;
	idle_state = true;
}
// **
else {
	idle_state = false;
	running_state = false;
	error_state = false;
	disabled_state = true;
}
} 

void setup() {
// RTC setup
 while (!Serial); 
 Serial.begin(9600);
 if (! rtc.begin()) {
   Serial.println("Couldn't find RTC");
   while (1);
 }
 if (! rtc.isrunning()) {
   Serial.println("RTC is NOT running!");
   // following line sets the RTC to the date & time this sketch was compiled
   rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
   // This line sets the RTC with an explicit date & time, for example to set
   // January 21, 2014 at 3am you would call:
   // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
 }
 
  // Stepper Motor
  myStepper.setSpeed(32); //sets stepper motor speed to 60 rpm
  SET_INPUT((unsigned char*) 0x10A, 0); //PL0 set as input
  SET_INPUT((unsigned char*) 0x10A, 1); //PL1 sets as input
  
  //Setting up lcd for temp/humd
  lcd.begin(16, 2);  	 //enables 16x2 lcd screen spaces
  
  pinMode (inputW, INPUT);
  pinMode (outputW, OUTPUT);
}

void loop() {
// RTC loop for time and date
 DateTime now = rtc.now();
 Serial.print("Time: ");
 Serial.print(now.hour(), DEC);
 Serial.print(':');
 Serial.print(now.minute(), DEC);
 Serial.print(':');
 Serial.print(now.second(), DEC);
 Serial.print(" Date: ");
 Serial.print(now.month(), DEC);
 Serial.print('/');
 Serial.print(now.day(), DEC);
 Serial.print('/');
 Serial.print(now.year(), DEC);
 Serial.print(" (");
 Serial.print(daysOfTheWeek[now.dayOfTheWeek()]);
 Serial.print(") ");
 Serial.println();
 delay(5000);
 
// Stepper Motor 
  if (*pin_l & 0x01){
    Serial.print("rotate ");
    // 2048 / 8 = 256
    // This is how many steps per revolution to create a 45 degree angle per button press
    Serial.print(stepsPerRev / 5.68889 ); 
    Serial.println("° clockwise");
    myStepper.step(-stepsPerRev); //negative value sends stepPerRev in reverse direvtion
    delay(500);
  }

else if (*pin_l & 0x02){
    Serial.print("rotate ");
    Serial.print(stepsPerRev / 5.68889 );
    Serial.println("° counter-clockwise");
    myStepper.step(stepsPerRev);
    delay(500);
  }

//Temp. and Humd. measure
//If device works and detects temp or humd, runs the code
if(measure_environment(&temp, &humd) == true){
    // Calculate temp from celcius to farenheight
    float op1 = temp*1.8;
    float op2 = op1 + 32;
    //printing valeus onto lcd screen
    lcd.setCursor(0,0);     //col 0 line 0 start
    lcd.print("Temperature=");
    lcd.print(op2,1);
    lcd.println("deg.F");
    lcd.setCursor(0,1);      //col 0 line 1 start
    lcd.print("Humidity = ");
    lcd.print(humd,1);
    lcd.println("% ");
    //6000 is 1 min, change around to test
    delay(6000); 
}    

//Water Level Detection
  Waterval = digitalRead(inputW);
   if(Waterval == 0){
    digitalWrite(inputW, 0);
    Serial.println("EMPTY");
   }
   else if(Waterval == LOW){
    digitalWrite(inputW, HIGH);
    Serial.println("HIGH");
   }
   else if(Waterval == HIGH){
    digitalWrite(inputW, HIGH);
    Serial.println("HIGH");
   }
  
}
// Enables the timer and interrupts
void setup_timer_registers() {
// Setup the timer control registers.
  OCR0A = 100;
  TCCR0A |= 0b00000010;   // CTC mode, internal clk, no prescaler
  TCCR0B |= 0b00000001;   // Start the timer, no prescaler                    
  TIMSK0 |= 0b00000010;   // Enable Timer0 Compare Match A Interrupt
}

// When water level is too low
void error_state() {
  *port_b |= 0b00010000;    // Turn on the red LED
  *port_b &= 0b00011111;    // Turn off the rest
  *port_f &= 0b11110111;    // Turn off the motor
  error_flag = 1;
}

// When monitoring and fan are disabled using an on/off button
void disabled_state() {
  *port_b |= 0b00100000;    // Turn on the yellow LED
  *port_b &= 0b00101111;    // Turn off the rest
  *port_f &= 0b11110111;    // Turn off the motor
  error_flag = 0;
}

// When water level is and temperature is low
void idle_state() {
  *port_b |= 0b01000000;    // Turn on the green LED
  *port_b &= 0b01001111;    // Turn off the rest
  *port_f &= 0b11110111;    // Turn off the motor
  error_flag = 0;
}

//Separate calculation	
static bool measure_environment(float *temp, float *humd)
{
	//calculating timestamp per milliseconds
  static unsigned long measurement_timestamp=millis();
  if(millis()-measurement_timestamp>3000ul)
  {
    if(dht_sensor.measure(temp,humd) == true)
    {
      measurement_timestamp = millis();
      return(true);
    }
  }
  return(false);
}
