// Name: Andrew Hignight, Mathew Rios, Ean McNeil, Michael Wang
// Date: 12/1/2022

#include <dht_nonblocking.h>
#include <Adafruit_Sensor.h>
#include <DHT.h>
#include <DHT_U.h>
#include <LiquidCrystal.h>

LiquidCrystal lcd(12,11,5,4,3,2); 
#define DHT_SENSOR_TYPE DHT_TYPE_11
int DHT_SENSOR_PIN = 9;
DHT_nonblocking dht_sensor(DHT_SENSOR_PIN,DHT_SENSOR_TYPE);

// Define data registers and ports
#define SET_OUTPUT(ddr, pin) *ddr |= (0x01 << pin);
#define SET_INPUT(ddr, pin) *ddr &= ~(0x01 << pin);
#define SET_HIGH(port, pin) *port |= (0x01 << pin);
#define SET_LOW(port, pin) *port &= ~(0x01 << pin);

// Port A Register
volatile unsigned char* port_A = (unsigned char*) 0x22;
volatile unsigned char* ddr_A = (unsigned char*) 0x21;
volatile unsigned char* pin_A = (unsigned char*) 0x20;

// Port B Register
volatile unsigned char* port_b = (unsigned char*) 0x25;
volatile unsigned char* ddr_b = (unsigned char*) 0x24;
volatile unsigned char* pin_b = (unsigned char*) 0x23;

// Define Port F Register Pointers
volatile unsigned char* port_f = (unsigned char*) 0x11; 
volatile unsigned char* ddr_f  = (unsigned char*) 0x10; 
volatile unsigned char* pin_f  = (unsigned char*) 0x0F; 

// Port L Registers
volatile unsigned char* port_l = (unsigned char*) 0x10B;
volatile unsigned char* ddr_l = (unsigned char*) 0x10A;
volatile unsigned char* pin_l = (unsigned char*) 0x109;

// Port D Registers
volatile usigned char* port_d = (usigned char*) 0x0B;
volatile usigned char* ddr_d = (usigned char*) 0x0A;
volatile usigned char* pin_d = (usigned char*) 0x09;

// ADC Register 
volatile unsigned char* my_ADMUX = (unsigned char*) 0x7C;
volatile unsigned char* my_ADCSRB = (unsigned char*) 0x7B;
volatile unsigned char* my_ADCSRA = (unsigned char*) 0x7A;
volatile unsigned char* my_ADC_Data = (unsigned char*) 0x78;

// External ISR Registers Control and Mask
volatile unsigned char* my_ECIRA = (unsigned char*) 0x69;
volatile unsigned char* my_EIMSK = (unsigned char*) 0x3D;
int count = 0;

// Initialize ADC
void adc_init()
{
  // setup the A register
  *my_ADCSRA |= 0b10000000; // set bit   7 to 1 to enable the ADC
  *my_ADCSRA &= 0b11011111; // clear bit 5 to 0 to disable the ADC trigger mode
  *my_ADCSRA &= 0b11011111; // clear bit 5 to 0 to disable the ADC interrupt
  *my_ADCSRA &= 0b11011111; // clear bit 5 to 0 to set prescaler selection to slow reading
  // setup the B register
  *my_ADCSRB &= 0b11110111; // clear bit 3 to 0 to reset the channel and gain bits
  *my_ADCSRB &= 0b11111000; // clear bit 2-0 to 0 to set free running mode
  // setup the MUX Register
  *my_ADMUX  &= 0b01111111; // clear bit 7 to 0 for AVCC analog reference
  *my_ADMUX  |= 0b01000000; // set bit   6 to 1 for AVCC analog reference
  *my_ADMUX  &= 0b11011111; // clear bit 5 to 0 for right adjust result
  *my_ADMUX  &= 0b11011111; // clear bit 5 to 0 for right adjust result
  *my_ADMUX  &= 0b11100000; // clear bit 4-0 to 0 to reset the channel and gain bits
}

// Bool Functions
bool DISABLED_ST, IDLE_ST, RUNNING_ST, ERROR_ST;

//Stepper Motor
const int stepsPerRev = 256;
Stepper myStepper(stepsPerRev, 8, 9, 10, 11); //initializes stepper motor on pins 8-11


// Definitions libraries, global definitions and declarations, ISR function, etc
int current_state;
int state_change = 0;
float Threshold_Temperature = 20;
char daysOfTheWeek[7][12] = ("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday");

// ISR 
ISR(INT2_vect){
count ++;
state_change = 1;

if(count%2 == 1) {
	disabled_state = false;
	running_state = false;
	error_state = false;
	idle_state = true;
}
else {
	idle_state = false;
	running_state = false;
	error_state = false;
	disabled_state = true;
}
} 

void setup() {

  // Stepper Motor
  myStepper.setSpeed(32); //sets stepper motor speed to 60 rpm
  SET_INPUT((unsigned char*) 0x10A, 0); //PL0 set as input
  SET_INPUT((unsigned char*) 0x10A, 1); //PL1 sets as input

  Serial.begin(9600);
  
  //Setting up lcd for temp/humd
  lcd.begin(16, 2);  	 //enables 16x2 lcd screen spaces

  
  
  
  
  
}
void loop() {

  //Stepper Motor 
  if (*pin_l & 0x01){
    Serial.print("rotate ");
    // 2048 / 8 = 256
    // This is how many steps per revolution to create a 45 degree angle per button press
    Serial.print(stepsPerRev / 5.68889 ); 
    Serial.println("° clockwise");
    myStepper.step(-stepsPerRev); //negative value sends stepPerRev in reverse direvtion
    delay(500);
  }
 else if (*pin_l & 0x02){

    Serial.print("rotate ");
    Serial.print(stepsPerRev / 5.68889 );
    Serial.println("° counter-clockwise");
    myStepper.step(stepsPerRev);
    delay(500);
  }
  // declaring variable for temp and humd which are decimal values
  float temp;
  float humd;
     //Temp. and Humd. measure
     //If device works and detects temp or humd, runs the code
  if(measure_environment(&temp, &humd) == true)
  {
  	// Calculate temp from celcius to farenheight
    lcd.setCursor(0,1);    //col 0 line 1 start
    lcd.setCursor(0,2);    //col 0 line 2 start
    float op1 = temp*1.8;
    float op2 = op1 + 32;
    	//printing valeus onto lcd screen
    lcd.print("Temperature = ");
    lcd.print(op2,1);
    lcd.println("deg. F, ");
    lcd.print("Humidity = ");
    lcd.print(humd,1);
    lcd.println("% ");
    //6000 is 1 min, change around to test
    delay(6000); 

}


// Enables the timer and interrupts
void setup_timer_registers() {
  // Setup the timer control registers.
  OCR0A = 100;
  TCCR0A |= 0b00000010;   // CTC mode, internal clk, no prescaler
  TCCR0B |= 0b00000001;   // Start the timer, no prescaler                    
  TIMSK0 |= 0b00000010;   // Enable Timer0 Compare Match A Interrupt
}

// When water level is too low
void error_state() {
  *port_b |= 0b00010000;    // Turn on the red LED
  *port_b &= 0b00011111;    // Turn off the rest
  *port_f &= 0b11110111;    // Turn off the motor
  error_flag = 1;
}

// When monitoring and fan are disabled using an on/off button
void disabled_state() {
  *port_b |= 0b00100000;    // Turn on the yellow LED
  *port_b &= 0b00101111;    // Turn off the rest
  *port_f &= 0b11110111;    // Turn off the motor
  error_flag = 0;
}

// When water level is and temperature is low
void idle_state() {
  *port_b |= 0b01000000;    // Turn on the green LED
  *port_b &= 0b01001111;    // Turn off the rest
  *port_f &= 0b11110111;    // Turn off the motor
  error_flag = 0;
}

//Separate calculation	
static bool measure_environment(float *temp, float *humd)
{
	//calculating timestamp per milliseconds
  static unsigned long measurement_timestamp=millis();
  if(millis()-measurement_timestamp>3000ul)
  {
    if(dht_sensor.measure(temp,humd) == true)
    {
      measurement_timestamp = millis();
      return(true);
    }
  }
  return(false);
}

int resvalWater = 0;  // holds the value
int respinWater = A5; // sensor pin used
  
void setup() { 
  lcd.begin(16, 2);  
  lcd.print("WATER LEVEL: "); 
} 

void loop() { 
  // set the cursor to column 0, line 1 
  lcd.setCursor(0, 1); 
    
  resval = analogRead(respin); //Read data from analog pin and store it to resval variable
   
  if (resval<=100){ 
    lcd.println("Empty"); 
  }
  else if (resval>100 && resval<=300){ 
    lcd.println("Low"); 
  } 
  else if (resval>300 && resval<=500){ 
    lcd.println("Medium"); 
  } 
  else if (resval>500){ 
    lcd.println("High"); 
  }
  delay(1000); 
}
